import React, { useState, useEffect } from 'react';
import { Dice1, Dice2, Dice3, Dice4, Dice5, Dice6, Square, Users, Trophy, RotateCcw, Info, XCircle, AlertCircle, HelpCircle } from 'lucide-react';

const MathTerritoryGame = () => {
  // éŠæˆ²ç‹€æ…‹
  const [gameStage, setGameStage] = useState('setup'); // setup, playing, finished
  const [playerCount, setPlayerCount] = useState(2); // Selected number of human players (1, 2, 3, or 4)
  const [grid, setGrid] = useState([]);
  const [players, setPlayers] = useState([]);
  const [currentTurn, setCurrentTurn] = useState(0);
  const [diceValues, setDiceValues] = useState([1, 1, 1]);
  const [isRolling, setIsRolling] = useState(false);
  const [possibleMoves, setPossibleMoves] = useState([]); // Used by human logic for skip check
  const [hasRolled, setHasRolled] = useState(false);
  const [winner, setWinner] = useState(null);
  const [showRules, setShowRules] = useState(false);
  
  // å›é¥‹è¨Šæ¯èˆ‡ç¢ºèªè¦–çª—ç‹€æ…‹
  const [feedback, setFeedback] = useState({ show: false, message: '', type: '' });
  const [showSkipConfirm, setShowSkipConfirm] = useState(false);
  // é‡ç½®ç¢ºèªç‹€æ…‹
  const [showResetConfirm, setShowResetConfirm] = useState(false); 

  // ç©å®¶é¡è‰²è¨­å®š
  const PLAYER_CONFIG = [
    { id: 0, name: 'ç©å®¶ 1', color: 'bg-red-500', lightColor: 'bg-red-100', border: 'border-red-500', text: 'text-red-600', isAI: false },
    { id: 1, name: 'ç©å®¶ 2', color: 'bg-blue-500', lightColor: 'bg-blue-100', border: 'border-blue-500', text: 'text-blue-600', isAI: false },
    { id: 2, name: 'ç©å®¶ 3', color: 'bg-green-500', lightColor: 'bg-green-100', border: 'border-green-500', text: 'text-green-600', isAI: false },
    { id: 3, name: 'ç©å®¶ 4', color: 'bg-yellow-500', lightColor: 'bg-yellow-100', border: 'border-yellow-500', text: 'text-yellow-600', isAI: false },
  ];
  
  // =========================================================================
  // ğŸ² éª°å­éŸ³æ•ˆå‡½å¼ (æ¨¡æ“¬å¤§å¯Œç¿éŠæˆ²çš„æ»¾å‹•è²)
  // =========================================================================
  const playDiceSound = () => {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (!audioContext) return;

      const numClacks = 30; // å¢åŠ è²éŸ¿æ¬¡æ•¸ï¼Œæ¨¡æ“¬é€£çºŒæ»¾å‹•
      const baseTime = audioContext.currentTime;
      const clackInterval = 0.03; // æ›´çŸ­çš„é–“éš”ï¼Œè®“è²éŸ³æ›´å¯†é›†é€£è²«

      for (let i = 0; i < numClacks; i++) {
        const time = baseTime + (i * clackInterval); 

        // 1. ç”¢ç”Ÿå™ªè² (Noise Generator)
        const noise = audioContext.createBufferSource();
        const bufferSize = audioContext.sampleRate * 0.1;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = buffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          output[j] = Math.random() * 2 - 1; // å¡«å……éš¨æ©Ÿå™ªè²
        }
        noise.buffer = buffer;

        // 2. éŸ³é‡æ§åˆ¶ (Gain Node)
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(0.001, time); 
        // å¿«é€Ÿä¸Šå‡ï¼Œä¸¦è®“éŸ³é‡åœ¨æ»¾å‹•ä¸­éš¨æ©Ÿè®ŠåŒ–
        gainNode.gain.linearRampToValueAtTime(0.1 + (Math.random() * 0.25), time + 0.005); 
        // å¿«é€Ÿè¡°æ¸› (æ¨¡æ“¬å–®æ¬¡æ•²æ“Š)
        const decayTime = 0.04; 
        gainNode.gain.exponentialRampToValueAtTime(0.001, time + decayTime); 

        // 3. å¸¶é€šæ¿¾æ³¢å™¨ (Filter) æ¨¡æ“¬ç©ºå¿ƒ clatter è²
        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass'; // è¨­ç½®ç‚ºå¸¶é€š
        // ä¸­å¿ƒé »ç‡åœ¨ 800-1200Hz ä¹‹é–“ï¼Œç”¢ç”Ÿæœ¨è³ªæ•²æ“Šæ„Ÿ
        filter.frequency.setValueAtTime(800 + (Math.random() * 400), time); 
        filter.Q.setValueAtTime(3 + (Math.random() * 2), time); // Qå€¼æ±ºå®šé »å¯¬ï¼Œè®“è²éŸ³æ›´é›†ä¸­

        // é€£æ¥ç¯€é»: å™ªè² -> éŸ³é‡ -> æ¿¾æ³¢ -> è¼¸å‡º
        noise.connect(gainNode);
        gainNode.connect(filter);
        filter.connect(audioContext.destination);

        // å•Ÿå‹•èˆ‡åœæ­¢è²éŸ¿ (åœæ­¢æ™‚é–“èˆ‡è¡°æ¸›æ™‚é–“ä¸€è‡´)
        noise.start(time);
        noise.stop(time + decayTime);
      }

    } catch (e) {
      // å¿½ç•¥éŸ³æ•ˆéŒ¯èª¤ï¼Œä¸å½±éŸ¿éŠæˆ²åŠŸèƒ½
      console.log("Failed to play dice sound:", e.message); 
    }
  };


  // åˆå§‹åŒ–éŠæˆ²
  const startGame = () => {
    // ç”¢ç”Ÿ 1-9 äº’ä¹˜çš„æ‰€æœ‰ä¸é‡è¤‡æ•¸å­— (å…± 36 å€‹)
    const uniqueProducts = new Set();
    for (let i = 1; i <= 9; i++) {
      for (let j = 1; j <= 9; j++) {
        uniqueProducts.add(i * j);
      }
    }

    // å°‡ Set è½‰ç‚ºé™£åˆ—ä¸¦éš¨æ©Ÿæ´—ç‰Œ
    const productArray = Array.from(uniqueProducts);
    for (let i = productArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [productArray[i], productArray[j]] = [productArray[j], productArray[i]];
    }

    const gridValues = productArray.slice(0, 36);

    const newGrid = gridValues.map((val, index) => {
      return {
        id: index,
        value: val,
        owner: null, 
      };
    });

    // è™•ç†å–®äººæ¨¡å¼ (Human vs. AI)
    let actualPlayerCount = playerCount;
    if (playerCount === 1) {
      actualPlayerCount = 2; // Human (0) vs. AI (1)
    }

    const newPlayers = PLAYER_CONFIG.slice(0, actualPlayerCount).map((p, index) => {
      const isAI = playerCount === 1 && index === 1;
      let name = p.name;
      if (playerCount === 1 && index === 0) {
        name = 'ç©å®¶'; // Human player name
      } else if (isAI) {
        name = 'é›»è…¦ AI ğŸ¤–'; // AI player name
      }
      
      return {
        ...p,
        name,
        score: 0,
        territories: 0,
        isAI: isAI // Add isAI flag
      };
    });

    setGrid(newGrid);
    setPlayers(newPlayers);
    setCurrentTurn(0);
    setDiceValues([1, 1, 1]);
    setHasRolled(false);
    setPossibleMoves([]);
    setGameStage('playing');
    setWinner(null);
    setFeedback({ show: false, message: '', type: '' });
    setShowSkipConfirm(false);
    setShowResetConfirm(false); // ç¢ºä¿é‡ç½®ç¢ºèªè¦–çª—é—œé–‰
  };

  // æ“²éª°å­é‚è¼¯ (äººé¡ç©å®¶)
  const rollDice = () => {
    setIsRolling(true);
    setPossibleMoves([]);
    setFeedback({ show: false, message: '', type: '' });
    setShowSkipConfirm(false);
    
    // [æ›´æ–°] æ’­æ”¾å¤§å¯Œç¿é¢¨æ ¼çš„éª°å­éŸ³æ•ˆ
    playDiceSound(); 
    
    let count = 0;
    const interval = setInterval(() => {
      setDiceValues([
        Math.floor(Math.random() * 9) + 1,
        Math.floor(Math.random() * 9) + 1,
        Math.floor(Math.random() * 9) + 1
      ]);
      count++;
      if (count > 10) {
        clearInterval(interval);
        finishRoll();
      }
    }, 100);
  };

  const finishRoll = () => {
    const d1 = Math.floor(Math.random() * 9) + 1;
    const d2 = Math.floor(Math.random() * 9) + 1;
    const d3 = Math.floor(Math.random() * 9) + 1;
    
    setDiceValues([d1, d2, d3]);
    setIsRolling(false);
    setHasRolled(true);

    const products = [d1 * d2, d1 * d3, d2 * d3];
    const uniqueProducts = [...new Set(products)];
    const moves = [];
    
    // è¨ˆç®—æ‰€æœ‰å¯èƒ½çš„ moves (ç”¨æ–¼äººé¡ç©å®¶çš„è·³éæª¢æŸ¥)
    grid.forEach(cell => {
      if (cell.owner === null && uniqueProducts.includes(cell.value)) {
        moves.push(cell.id);
      }
    });

    setPossibleMoves(moves);
  };

  // è™•ç†æ ¼å­é»æ“Š (äººé¡ç©å®¶)
  const handleCellClick = (cellId) => {
    if (!hasRolled || gameStage !== 'playing') return;
    if (grid[cellId].owner !== null) return; 

    // é‡æ–°è¨ˆç®—å¯èƒ½çš„ä¹˜ç© (é¿å… possibleMoves ç‹€æ…‹å»¶é²)
    const [d1, d2, d3] = diceValues;
    const products = [d1 * d2, d1 * d3, d2 * d3];
    const uniqueProducts = [...new Set(products)];

    if (uniqueProducts.includes(grid[cellId].value)) {
      const newGrid = [...grid];
      newGrid[cellId].owner = currentTurn;
      setGrid(newGrid);
      setFeedback({ show: false, message: '', type: '' });

      updateScores(newGrid);
      checkGameEnd(newGrid);
    } else {
      showFeedback('ç®—éŒ¯å›‰ï¼é€™ä¸æ˜¯éª°å­ç›¸ä¹˜çš„çµæœï¼Œå†ç®—ç®—çœ‹ã€‚', 'error');
    }
  };

  const showFeedback = (msg, type) => {
    setFeedback({ show: true, message: msg, type });
    setTimeout(() => {
      setFeedback(prev => ({ ...prev, show: false }));
    }, 2500);
  };

  // è™•ç†è·³éè«‹æ±‚ (äººé¡ç©å®¶)
  const handleSkipRequest = () => {
    if (possibleMoves.length > 0) {
      // é‚„æœ‰ç­”æ¡ˆï¼Œè·³å‡ºç¢ºèªæ¡†
      setShowSkipConfirm(true);
    } else {
      // çœŸçš„æ²’ç­”æ¡ˆï¼Œç›´æ¥è·³é
      confirmSkip();
    }
  };

  // ç¢ºèªåŸ·è¡Œè·³é
  const confirmSkip = () => {
    setShowSkipConfirm(false);
    setFeedback({ show: false, message: '', type: '' });
    updateScores(grid); // Update scores just in case
    nextTurn();
  };
  
  // è™•ç†é‡ç½®éŠæˆ²è«‹æ±‚
  const handleResetRequest = () => {
    setShowResetConfirm(true);
  };
  
  // ç¢ºèªåŸ·è¡Œé‡ç½®
  const confirmReset = () => {
    setShowResetConfirm(false);
    setGameStage('setup');
  };

  const nextTurn = () => {
    setHasRolled(false);
    setPossibleMoves([]);
    // å¾ªç’°åˆ°ä¸‹ä¸€ä½ç©å®¶
    setCurrentTurn((prev) => (prev + 1) % players.length);
  };

  // å–å¾—é„°å±…
  const getNeighbors = (index) => {
    const row = Math.floor(index / 6);
    const col = index % 6;
    const neighbors = [];

    if (row > 0) neighbors.push(index - 6); // Up
    if (row < 5) neighbors.push(index + 6); // Down
    if (col > 0) neighbors.push(index - 1); // Left
    if (col < 5) neighbors.push(index + 1); // Right

    return neighbors;
  };
  
  // æ›´æ–°åˆ†æ•¸ (ä¸¦è¿”å›æœ€æ–°ç©å®¶åˆ—è¡¨)
  const updateScores = (currentGrid) => {
    const updatedPlayers = players.map(player => {
      let baseScore = 0;
      let territoryCount = 0;

      currentGrid.forEach((cell, index) => {
        if (cell.owner === player.id) {
          territoryCount++;
          const neighbors = getNeighbors(index);
          // æª¢æŸ¥æ˜¯å¦èˆ‡è‡ªå·±çš„åœ°ç›¸é€£
          const isConnected = neighbors.some(nIndex => currentGrid[nIndex] && currentGrid[nIndex].owner === player.id);
          // ç›¸é€£å¾— 2 åˆ†ï¼Œå­¤ç«‹å¾— 1 åˆ†
          baseScore += isConnected ? 2 : 1;
        }
      });

      return { ...player, score: baseScore, territories: territoryCount, isAI: player.isAI || false };
    });
    setPlayers(updatedPlayers);
    return updatedPlayers; 
  };

  // æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
  const checkGameEnd = (currentGrid) => {
    const isFull = currentGrid.every(cell => cell.owner !== null);
    if (isFull) {
      // ç¢ºä¿åˆ†æ•¸æ›´æ–°å®Œç•¢å¾Œå†åˆ¤å®šå‹è€…
      const finalPlayers = updateScores(currentGrid); 
      setGameStage('finished');
      const sortedPlayers = [...finalPlayers].sort((a, b) => b.score - a.score);
      setWinner(sortedPlayers[0]);
    } else {
      nextTurn();
    }
  };
  
  // =========================================================================
  // é›»è…¦ AI é‚è¼¯
  // =========================================================================
  const handleAIMove = (aiPlayer) => {
    // 1. æ¨¡æ“¬æ“²éª°å‹•ç•«
    setIsRolling(true);
    playDiceSound(); // AI æ“²éª°ä¹Ÿæ’­æ”¾éŸ³æ•ˆ
    
    // å»¶é² 0.5 ç§’å¾Œç¢ºå®šéª°å­çµæœ
    setTimeout(() => {
        // æœ€çµ‚æ“²éª°çµæœ (1-9)
        const d1 = Math.floor(Math.random() * 9) + 1;
        const d2 = Math.floor(Math.random() * 9) + 1;
        const d3 = Math.floor(Math.random() * 9) + 1;
        const finalDice = [d1, d2, d3];

        // æ›´æ–° UI ç‹€æ…‹
        setDiceValues(finalDice);
        setIsRolling(false);
        setHasRolled(true);

        const products = [d1 * d2, d1 * d3, d2 * d3];
        const uniqueProducts = [...new Set(products)];
        
        // 2. AI æ±ºç­– (æ‰¾å‡ºæœ€ä½³è½é»)
        const moves = [];
        grid.forEach(cell => {
          if (cell.owner === null && uniqueProducts.includes(cell.value)) {
            moves.push({ id: cell.id, value: cell.value });
          }
        });

        let bestMoveId = null;
        let maxScore = 0;
        
        const currentGrid = grid; 

        for (const move of moves) {
            const neighbors = getNeighbors(move.id);
            // æª¢æŸ¥æ˜¯å¦èƒ½ç›¸é€£ (2 åˆ†)
            const isConnected = neighbors.some(nIndex => currentGrid[nIndex].owner === aiPlayer.id);
            const score = isConnected ? 2 : 1;
            
            // ç­–ç•¥ï¼šé¸æ“‡èƒ½æ‹¿æœ€é«˜åˆ†æ•¸ (2åˆ†) çš„æ ¼å­ï¼Œè‹¥å¹³æ‰‹å‰‡éš¨æ„
            if (score > maxScore) {
                maxScore = score;
                bestMoveId = move.id;
            }
        }
        
        // 3. åŸ·è¡Œå‹•ä½œ (å»¶é² 1 ç§’æ¨¡æ“¬æ€è€ƒæ™‚é–“)
        setTimeout(() => {
          if (bestMoveId !== null) {
            const newGrid = [...grid];
            newGrid[bestMoveId].owner = aiPlayer.id;
            
            setGrid(newGrid);
            updateScores(newGrid);
            checkGameEnd(newGrid); 
          } else {
            // AI è·³é
            showFeedback('é›»è…¦ AI é¸æ“‡è·³éå›åˆã€‚', 'info');
            nextTurn(); 
          }
          
          setPossibleMoves([]); // æ¸…é™¤å¯èƒ½çš„æ­¥æ•¸
        }, 1000); 
    }, 500); // æ¨¡æ“¬æ“²éª°å‹•ç•«å»¶é²
  };
  
  // =========================================================================
  // useEffect è™•ç† AI è‡ªå‹•å›åˆ
  // =========================================================================
  useEffect(() => {
    if (players.length > 0 && gameStage === 'playing') {
        const aiPlayer = players.find(p => p.id === currentTurn && p.isAI);
        if (aiPlayer) {
          handleAIMove(aiPlayer);
        }
    }
  }, [currentTurn, players, gameStage, grid]); // å¿…é ˆä¾è³´ grid æ‰èƒ½åœ¨ AI æ±ºç­–æ™‚æ‹¿åˆ°æœ€æ–°ç›¤é¢

  // =========================================================================
  // çµ„ä»¶æ¸²æŸ“
  // =========================================================================

  const DiceDisplay = ({ value }) => {
    return (
      <div className="w-12 h-12 bg-white border-2 border-gray-800 rounded-lg flex items-center justify-center text-xl font-bold shadow-md">
        {value}
      </div>
    );
  };

  const isCurrentPlayerAI = players[currentTurn]?.isAI;

  if (gameStage === 'setup') {
    return (
      <div className="min-h-screen bg-green-50 flex flex-col items-center justify-center p-4 font-sans">
        <div className="bg-white p-6 md:p-8 rounded-3xl shadow-2xl max-w-md w-full text-center border-4 border-green-500">
          <h1 className="text-4xl font-black text-green-600 mb-2 tracking-wider">âœ¨ ä¹ä¹ä¹˜æ³• âœ¨</h1>
          <h2 className="text-2xl font-bold text-green-500 mb-6">ğŸ° ä½”åœ°éŠæˆ² 2.0 ğŸ°</h2>
          
          <div className="bg-green-50 p-5 rounded-2xl mb-6 text-left border-2 border-green-200 shadow-inner">
            <h3 className="font-bold text-green-800 mb-3 text-center text-lg flex items-center justify-center gap-2">
              <Info size={20} className="text-green-600"/> æ€éº¼ç©ï¼Ÿ
            </h3>
            <ul className="space-y-2 text-green-700 text-sm font-medium">
              <li className="flex items-start gap-2">
                <span className="text-lg">ğŸ²</span> 
                <span><b>æ“²éª°å­</b>ï¼šæ¯å›åˆæ“²å‡º 3 é¡†æ•¸å­—éª°ã€‚</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-lg">ğŸ§®</span> 
                <span><b>ç®—ä¹˜æ³•</b>ï¼šä»»é¸ 2 é¡†éª°å­ç›¸ä¹˜ã€‚</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-lg">ğŸš©</span> 
                <span><b>ä½”é ˜åœ°</b>ï¼šé»æ“Šå°æ‡‰çš„æ•¸å­—æ ¼å­ä½”é ˜ã€‚</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-lg">ğŸ”—</span> 
                <span><b>é€£é€£çœ‹</b>ï¼šèˆ‡è‡ªå·±åœŸåœ°ç›¸é€£ï¼Œåˆ†æ•¸åŠ å€ï¼</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-lg">ğŸ‘‘</span> 
                <span><b>çˆ­å† è»</b>ï¼šåœŸåœ°è¢«ä½”æ»¿å¾Œï¼Œåˆ†æ•¸é«˜è€…ç²å‹ã€‚</span>
              </li>
            </ul>
          </div>

          <div className="mb-8">
            <label className="block text-gray-700 text-lg font-bold mb-4">ğŸ‘¥ é¸æ“‡ç©å®¶äººæ•¸</label>
            <div className="flex justify-center gap-4">
              {[1, 2, 3, 4].map(num => (
                <button
                  key={num}
                  onClick={() => setPlayerCount(num)}
                  className={`w-16 h-16 rounded-2xl text-2xl font-black transition-all duration-200 border-b-4 ${
                    playerCount === num 
                      ? 'bg-green-500 text-white border-green-700 scale-110 shadow-lg translate-y-[-4px]' 
                      : 'bg-gray-100 text-gray-400 border-gray-300 hover:bg-gray-200 hover:border-gray-400'
                  }`}
                >
                  {num}
                </button>
              ))}
            </div>
          </div>

          <button
            onClick={startGame}
            className="w-full bg-gradient-to-b from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white text-xl font-black py-4 rounded-2xl shadow-lg border-b-4 border-green-800 active:border-b-0 active:translate-y-1 transition-all flex items-center justify-center gap-2 group"
          >
            <Dice5 size={28} className="group-hover:rotate-180 transition-transform duration-500"/>
            é–‹å§‹éŠæˆ² GO!
          </button>

          <div className="mt-6 text-green-400 text-xs font-bold tracking-widest">
            éŠæˆ²è¨­è¨ˆï¼šå°ç›Šçš„å¸ƒæ‹‰æ ¼å»£å ´FBï¼›ç¶²é è¨­è¨ˆï¼šå½­å½­è€å¸«
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-slate-100 p-2 md:p-6 font-sans flex flex-col md:flex-row gap-4 max-w-7xl mx-auto">
      {/* å·¦å´ï¼šè¨ˆåˆ†æ¿ */}
      <div className="w-full md:w-1/4 flex flex-col gap-4 order-2 md:order-1">
        <div className="bg-white rounded-xl shadow-md p-4 border-t-4 border-green-600">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-bold text-gray-800 flex items-center gap-2">
              <Users size={20} />
              è¨ˆåˆ†æ¿
            </h3>
            <button 
              onClick={() => setShowRules(!showRules)}
              className="text-gray-400 hover:text-green-600"
            >
              <Info size={20} />
            </button>
          </div>
          
          <div className="space-y-3">
            {players.map((player) => (
              <div 
                key={player.id} 
                className={`flex justify-between items-center p-3 rounded-lg border-l-4 ${player.border} ${currentTurn === player.id ? 'bg-gray-50 shadow-inner ring-2 ring-offset-1 ring-green-400' : 'bg-white'}`}
              >
                <div>
                  <span className={`font-bold block ${player.text}`}>{player.name}</span>
                  <span className="text-xs text-gray-500">ä½”åœ°: {player.territories}</span>
                </div>
                <div className="text-2xl font-black text-gray-700">{player.score}</div>
              </div>
            ))}
          </div>
        </div>

        {showRules && (
          <div className="bg-yellow-50 border border-yellow-200 rounded-xl p-4 text-sm text-yellow-800">
            <h4 className="font-bold mb-2">éŠæˆ²è¦å‰‡ï¼š</h4>
            <ul className="list-disc list-inside space-y-1">
              <li>æ“² 3 é¡† 1-9 æ•¸å­—éª°å­ã€‚</li>
              <li>ä»»é¸å…¶ä¸­å…©é¡†ç›¸ä¹˜ã€‚</li>
              <li>ä¹˜ç©å³ç‚ºå¯ä½”é ˜çš„åœŸåœ°ã€‚</li>
              <li>ä¸€å¡Šåœ°å¾— 1 åˆ†ã€‚</li>
              <li>èˆ‡è‡ªå·±é ˜åœŸ<strong>ç›¸é€£</strong>çš„åœ°ï¼Œåˆ†æ•¸åŠ å€ã€‚</li>
              <li>è‹¥ç„¡åœ°å¯ä½”ï¼Œè«‹æŒ‰ã€Œè·³éå›åˆã€ã€‚</li>
            </ul>
          </div>
        )}
      </div>

      {/* ä¸­é–“ï¼šæ£‹ç›¤ */}
      <div className="flex-1 flex flex-col items-center justify-center order-1 md:order-2 relative">
        
        {/* éŒ¯èª¤/æç¤ºè¨Šæ¯è¦†è“‹å±¤ */}
        {feedback.show && (
          <div className="absolute top-4 z-10 animate-bounce">
             <div className={`px-6 py-3 rounded-full shadow-lg font-bold flex items-center gap-2 ${feedback.type === 'error' ? 'bg-red-500 text-white' : 'bg-green-500 text-white'}`}>
               {feedback.type === 'error' ? <AlertCircle size={20}/> : <Info size={20}/>}
               {feedback.message}
             </div>
          </div>
        )}

        <div className="bg-white p-2 md:p-6 rounded-xl shadow-xl border-4 border-gray-800">
           <div className="grid grid-cols-6 gap-1 md:gap-2 bg-gray-300 p-1 md:p-2 rounded">
             {grid.map((cell) => {
               const owner = players.find(p => p.id === cell.owner);
               const isOccupied = cell.owner !== null;
               
               return (
                 <button
                   key={cell.id}
                   // åªæœ‰é AI ç©å®¶çš„å›åˆä¸”å·²æ“²éª°æ‰èƒ½é»æ“Š
                   disabled={isCurrentPlayerAI || !hasRolled || isOccupied}
                   onClick={() => handleCellClick(cell.id)}
                   className={`
                     w-12 h-12 md:w-20 md:h-20 flex items-center justify-center text-lg md:text-2xl font-black rounded transition-all duration-200
                     ${cell.owner === null ? 'bg-gray-100 text-gray-800 hover:bg-gray-200' : `${owner?.color} text-white shadow-inner`}
                     ${(isCurrentPlayerAI || !hasRolled) && cell.owner === null ? 'opacity-50 cursor-not-allowed' : ''}
                     ${!isCurrentPlayerAI && hasRolled && !isOccupied ? 'cursor-pointer hover:scale-105 hover:shadow-md active:scale-95' : ''}
                   `}
                 >
                   {cell.value}
                 </button>
               );
             })}
           </div>
        </div>
      </div>

      {/* å³å´/ä¸‹æ–¹ï¼šæ§åˆ¶å€ */}
      <div className="w-full md:w-1/4 flex flex-col gap-4 order-3">
        <div className={`bg-white rounded-xl shadow-lg p-6 border-t-4 ${players[currentTurn]?.border}`}>
          <div className="text-center mb-4">
            <span className="text-gray-500 text-sm uppercase tracking-wider">ç•¶å‰å›åˆ</span>
            <h2 className={`text-2xl font-bold ${players[currentTurn]?.text}`}>
              {players[currentTurn]?.name}
            </h2>
          </div>

          <div className="flex justify-center gap-3 mb-6">
            {diceValues.map((val, i) => (
              <DiceDisplay key={i} value={val} />
            ))}
          </div>

          {!hasRolled && !isCurrentPlayerAI ? (
            <button
              onClick={rollDice}
              disabled={isRolling}
              className={`w-full py-4 rounded-xl text-white font-bold text-lg shadow-lg flex items-center justify-center gap-2 transition-all active:scale-95 ${isRolling ? 'bg-gray-400' : 'bg-gray-800 hover:bg-gray-900'}`}
            >
              {isRolling ? 'æ“²éª°ä¸­...' : (
                <>
                  <Dice5 /> æ“²éª°å­
                </>
              )}
            </button>
          ) : isCurrentPlayerAI ? (
             <div className="w-full py-4 bg-gray-200 text-gray-600 rounded-xl text-center font-bold text-lg animate-pulse">
               é›»è…¦ AI æ€è€ƒä¸­...
             </div>
          ) : (
            <div className="space-y-3">
              <div className="text-center text-gray-600 font-bold mb-2">
                 è«‹é»é¸è¨ˆç®—å‡ºçš„ä¹˜ç©æ ¼å­
              </div>
              
              {/* ç•¶æ²’æœ‰æ­¥æ•¸æ™‚æ‰é¡¯ç¤ºè·³éï¼Œé¿å…å¡é—œï¼Œä½†ä¸é¡¯ç¤ºåŸå›  */}
              {possibleMoves.length === 0 && (
                <div className="bg-red-50 text-red-600 p-2 rounded text-center text-sm mb-2">
                  ä¼¼ä¹æ²’æœ‰å¯ä»¥ä½”é ˜çš„æ ¼å­å›‰...
                </div>
              )}

              <button
                onClick={handleSkipRequest}
                className="w-full py-3 bg-red-100 text-red-600 hover:bg-red-200 rounded-xl font-bold flex items-center justify-center gap-2"
              >
                <XCircle size={20} /> è·³éå›åˆ
              </button>
            </div>
          )}
        </div>

        <button 
          onClick={handleResetRequest} // å‘¼å«ç¢ºèªè¦–çª—
          className="bg-white text-gray-500 hover:text-red-500 p-4 rounded-xl shadow hover:shadow-md transition-all flex items-center justify-center gap-2"
        >
          <RotateCcw size={18} /> é‡ç½®éŠæˆ²
        </button>
      </div>

      {/* è·³éç¢ºèª Modal */}
      {showSkipConfirm && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="bg-white p-6 rounded-3xl shadow-2xl max-w-sm w-full text-center animate-fade-in-up border-4 border-yellow-400">
            <div className="flex justify-center mb-4">
               <HelpCircle size={64} className="text-yellow-500" />
            </div>
            <h3 className="text-2xl font-black text-gray-800 mb-4">ç¢ºå®šè¦è·³éå—ï¼Ÿ</h3>
            <p className="text-gray-600 mb-8 font-medium">
              ç›¤é¢ä¸Šé‚„æœ‰å¯ä»¥ä½”é ˜çš„ç­”æ¡ˆå–”ï¼<br/>
              å†ä»”ç´°ç®—ç®—çœ‹ï¼Ÿ
            </p>
            <div className="flex gap-3 justify-center">
               <button
                 onClick={() => setShowSkipConfirm(false)}
                 className="flex-1 py-3 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-xl font-bold transition-colors"
               >
                 æˆ‘å†æƒ³æƒ³
               </button>
               <button
                 onClick={confirmSkip}
                 className="flex-1 py-3 bg-red-500 hover:bg-red-600 text-white rounded-xl font-bold shadow-lg transition-transform active:scale-95"
               >
                 å¿ç—›è·³é
               </button>
            </div>
          </div>
        </div>
      )}
      
      {/* é‡ç½®ç¢ºèª Modal */}
      {showResetConfirm && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="bg-white p-6 rounded-3xl shadow-2xl max-w-sm w-full text-center animate-fade-in-up border-4 border-red-400">
            <div className="flex justify-center mb-4">
               <AlertCircle size={64} className="text-red-500" />
            </div>
            <h3 className="text-2xl font-black text-gray-800 mb-4">ç¢ºå®šè¦é‡ç½®éŠæˆ²å—ï¼Ÿ</h3>
            <p className="text-gray-600 mb-8 font-medium">
              éŠæˆ²å°‡æœƒå›åˆ°è¨­å®šç•«é¢ï¼Œç›®å‰çš„é€²åº¦å°‡æœƒéºå¤±ã€‚
            </p>
            <div className="flex gap-3 justify-center">
               <button
                 onClick={() => setShowResetConfirm(false)}
                 className="flex-1 py-3 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-xl font-bold transition-colors"
               >
                 å–æ¶ˆ
               </button>
               <button
                 onClick={confirmReset}
                 className="flex-1 py-3 bg-red-500 hover:bg-red-600 text-white rounded-xl font-bold shadow-lg transition-transform active:scale-95"
               >
                 ç¢ºèªé‡ç½®
               </button>
            </div>
          </div>
        </div>
      )}

      {/* éŠæˆ²çµæŸ Modal */}
      {gameStage === 'finished' && winner && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="bg-white p-8 rounded-2xl shadow-2xl max-w-sm w-full text-center animate-fade-in-up">
            <div className="flex justify-center mb-4">
               <Trophy size={64} className="text-yellow-500" />
            </div>
            <h2 className="text-3xl font-black text-gray-800 mb-2">éŠæˆ²çµæŸ!</h2>
            <p className="text-gray-500 mb-6">æ‰€æœ‰çš„åœŸåœ°éƒ½è¢«ä½”é ˜äº†</p>
            
            <div className="bg-yellow-50 p-4 rounded-xl border-2 border-yellow-200 mb-6">
              <span className="text-sm text-yellow-600 font-bold uppercase">ç²å‹è€…</span>
              <div className={`text-3xl font-black ${winner.text} mt-1`}>
                {winner.name}
              </div>
              <div className="text-2xl font-bold text-gray-700 mt-2">
                {winner.score} åˆ†
              </div>
            </div>

            <button
              onClick={startGame}
              className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-xl shadow-lg"
            >
              å†ç©ä¸€æ¬¡
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default MathTerritoryGame;
